#include "formatter.hpp"
#include "protobuf.zig.hpp"

namespace ZigProtobuf{

/**
 * Remove the .proto extension from a filename 
 */
std::string Formatter::StripProtoFromName(const std::string& filename)
{
    std::size_t found = filename.find(".proto");
    if(std::string::npos == found){
        return filename;
    }

    return filename.substr(0, found);
}


/**
 * Prevent name collisions by adding the @"" syntax to reserverd words
 */
std::string Formatter::GetZigName(const std::string& field_name)
{
    //https://ziglang.org/documentation/master/#Grammar
    static const std::vector<std::string> reserved{"test"}; //TODO add rest of reserved words

    if(std::find(reserved.begin(),reserved.end(), field_name) != reserved.end()){
        return "@\"" + field_name + "\"";
    }

    return field_name;
}


/**
 * Create the new file and write the header
 */
Formatter::Formatter(const google::protobuf::FileDescriptor* file, google::protobuf::compiler::GeneratorContext* generator_context) 
{
    io = std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream>(
        generator_context->Open(StripProtoFromName(file->name())  + ".pb.zig"));

    printer = std::make_unique<google::protobuf::io::Printer>(io.get(), variable_delimiter);

    //add header to new file created
    WriteLine({AUTOGENERATED_NOTICE})
        .WriteLine({ZIGPB_VERSION, google::protobuf::internal::VersionString(GOOGLE_PROTOBUF_VERSION), ", source: ", file->name()})
        .WriteLine({})
        .WriteLine({"const std = @import(\"std\");"})
        .WriteLine({"const __zig_protobuf = @import(\"protobuf.zig\");"})
        .WriteLine({"const ProtobufMessage = __zig_protobuf.ProtobufMessage;"})
        .WriteLine({"const DecodeError = __zig_protobuf.DecodeError;"})
        .WriteLine({"const EncodeError = __zig_protobuf.EncodeError;"})
        .WriteLine({"const Allocator = std.mem.Allocator;"});

    std::vector<const google::protobuf::FileDescriptor*> output;
    generator_context->ListParsedFiles(&output);
}


Formatter& Formatter::Write(const std::initializer_list<std::string>& args)
{
    std::string buffer = use_indent ? indent : "";
    for(const auto& word : args){
        buffer += word;
    }

    printer->PrintRaw(buffer);
    return *this;
}


Formatter&  Formatter::WriteLine(const std::initializer_list<std::string>& args)
{
    return Write(args).NewLine();
}


Formatter&  Formatter::NewLine()
{
    printer->PrintRaw("\n");
    return *this;
}


/**
 * Add the protobuf interface to the directory of autogenerated files 
 */
void Formatter::CopyProtobufInterfaceFiles(google::protobuf::compiler::GeneratorContext* generator_context)
{
    //copy the zig files containing the decoder/encoder interfaces into the generated directory
    auto io = std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream>(generator_context->Open(zig_protobuf_file.data()));

    //create the header
    auto printer = google::protobuf::io::Printer(io.get(), variable_delimiter);
    printer.PrintRaw(AUTOGENERATED_NOTICE "\n");
    printer.PrintRaw(ZIGPB_VERSION + google::protobuf::internal::VersionString(GOOGLE_PROTOBUF_VERSION) + "\n");

    printer.PrintRaw(zig_encoding_interface.data());
}

}
